__all__ = (
    'SegmentTree',
)


class SegmentTree:
    """线段树.

    为什么要申请 4N 大小的树来存储 N 个元素 ?

    答: 首先, 树中每一层元素的个数必须是 2 的几次方. 其次, 最后一层的个数减一
    等于之前所有层的个数, 假设我们已知最后一个层个数为 a, 可得整个树的元素个数为
    a + a - 1 ~= 2a, 因而上述问题可变为: 存储 N 个元素, 最后一层的大小是多少 ?
    假设当 N = 8 时, 由于 8 正好等于 2 ** 3, 因而最后一层个数就等于 8,
    最终需要申请 2 * 16 = 16 大小的树. 当 N = 9 时, 需要寻找大于 9 且最近的 2 的几次方,
    此值为 16, 因而最后一层个数等于 16, 最终需要申请 2 * 16 = 32 大小的树.
    在上面这种方式中我们每次都需要计算 log(2, N) 找到一个值, 比较麻烦. 如果我们
    每次都让 N 个元素的最后一行为 2N 个, 就不需要计算 log2 了. 当 N = 8 时,
    8 * 4 > 8 * 2 = 16, 当 N = 9 时, 9 * 4 > 8 * 4 = 32.
    """

    def __init__(self, array: list):
        self._array = array[:]
        self._tree = [None for _ in range(len(array) * 4)]
